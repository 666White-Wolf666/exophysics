<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Morphogen</title>
        <style type="text/css">
            body {
                background: radial-gradient(circle at top, #336, #000 75%);
                min-height: 100vh;
                padding: 0 1em;
                margin: 0;
                text-align: center;
            }
            #canvas {
                margin: 10pt;
                background: #000;
                box-shadow: 0 0 10px #429;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas" width="800" height="600"></canvas>
        <script>
            var options = {
                particleLimit: 256 // Keep this in sync with particleLimit in vertex shader!
            }
        </script>
        <script type="x-shader/x-vertex" id="vertex-shader">
            #version 300 es
            const int particleLimit = min(gl_MaxVertexUniformVectors, 256);
            uniform vec2 allPositions[particleLimit];
            in vec4 oldPos;
            in vec4 oldV;
            in int currentIndex;
            out vec2 newPos;
            out vec2 newV;
            out lowp vec4 color;

            void main() {
                vec2 particle_pos;
                vec2 center_of_mass;
                center_of_mass = vec2(0.0, 0.0);
                for (int i = 0; i < particleLimit; i++) {
                    particle_pos = allPositions[i];
                    center_of_mass += particle_pos;
                }
                center_of_mass /= float(particleLimit) * 1.1;
                vec2 dist = allPositions[currentIndex] - center_of_mass;

                newPos.x = oldPos.x + oldV.x;
                newPos.y = oldPos.y + oldV.y;
                if (newPos.x < -1.0) {
                    newPos.x = -1.0;
                }
                if (newPos.x > 1.0) {
                    newPos.x = 1.0;
                }
                if (newPos.y < -1.0) {
                    newPos.y = -1.0;
                }
                if (newPos.y > 1.0) {
                    newPos.y = 1.0;
                }
                newV.x = oldV.x - dist.x / 10000.0;
                newV.y = oldV.y - dist.y / 10000.0;
                color.b = min(1.0, max(0.0, abs(newV.x) * 255.0));
                color.g = min(1.0, max(0.0, abs(newV.y) * 255.0));
                color.r = 1.0 - (color.r + color.b) / 2.0;
                color.a = 1.0;

                gl_Position.xy = newPos.xy;
                gl_Position.zw = vec2(0.0, 1.0);
                gl_PointSize = 4.0 - 2.0 * min(1.0, max(0.0, (newV.x + newV.y) * 50.0));
            }
        </script>
        <script type="x-shader/x-fragment" id="fragment-shader">
            #version 300 es
            precision highp float;
            in vec4 color;
            out vec4 outColor;
            void main() { outColor = color; }
        </script>
        <script type="application/javascript">
            "use strict";

            main(options);

            function main(options) {
                const canvas = document.querySelector('#canvas');
                const gl = canvas.getContext('webgl2');
                if (!gl) {
                    alert('Unable to initialize WebGL. Your browser or machine may not support it.');
                    return;
                }
                options.particleLimit = Math.min(options.particleLimit,
                    gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS))
                const shaderInfo = initShaders(gl);
                const buffers = initBuffers(gl, options);
                drawScene(gl, shaderInfo, buffers, options);
            }

            function initShaders(gl) {
                const vertexSource = document.getElementById("vertex-shader").text
                const fragmentSource = document.getElementById("fragment-shader").text
                const feedbackVars = ['newPos', 'newV'];
                const shaderProgram = createProgram(gl, vertexSource, fragmentSource, feedbackVars);

                const shaderInfo = {
                    program: shaderProgram,
                    attribLocations: {
                        oldPos: gl.getAttribLocation(shaderProgram, 'oldPos'),
                        oldV: gl.getAttribLocation(shaderProgram, 'oldV'),
                        currentIndex: gl.getAttribLocation(shaderProgram, 'currentIndex'),
                    },
                    uniformLocations: {
                        allPositions: gl.getUniformLocation(shaderProgram, 'allPositions'),
                    },
                };
                return shaderInfo;
            }

            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            function createProgram(gl, vertexSource, fragmentSource, feedbackVars) {
                const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource.trim());
                const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource.trim());
                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.transformFeedbackVaryings(shaderProgram, feedbackVars, gl.SEPARATE_ATTRIBS);
                gl.linkProgram(shaderProgram);

                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                    return null;
                }
                return shaderProgram;
            }

            function initBuffers(gl, options) {
                // initiate with random positions
                const oldPos = [...Array(options.particleLimit * 2)].map(_=>Math.random() * 2 - 1);
                const oldPosBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, oldPosBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(oldPos), gl.DYNAMIC_DRAW);

                // initiate with random velocity
                const oldV = [...Array(options.particleLimit * 2)].map(_=>(Math.random() * 2 - 1) * 0.005);
                const oldVBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, oldVBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(oldV), gl.DYNAMIC_DRAW);

                var currentIndex = [];
                var i;
                for (i = 0; i < options.particleLimit; i++) {
                    currentIndex[i] = i;
                }
                const currentIndexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, currentIndexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Int32Array(currentIndex), gl.STATIC_DRAW);

                var newPosBuffer = gl.createBuffer();
                var newVBuffer = gl.createBuffer();

                return {
                    oldPos: oldPosBuffer,
                    oldV: oldVBuffer,
                    newPos: newPosBuffer,
                    newV: newVBuffer,
                    currentIndex: currentIndexBuffer,
                };
            }

            function drawScene(gl, programInfo, buffers, options) {
                gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
                gl.clearDepth(1.0);                 // Clear everything
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                const vao = gl.createVertexArray();
                gl.bindVertexArray(vao);

                var size = 2;
                var type = gl.FLOAT;
                var normalize = false;
                var stride = 0;
                var offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.oldPos);
                gl.vertexAttribPointer(programInfo.attribLocations.oldPos,
                    size, type, normalize, stride, offset);
                gl.enableVertexAttribArray(programInfo.attribLocations.oldPos);

                // TODO: pass all positions on first frame too.

                var size = 2;
                var type = gl.FLOAT;
                var normalize = false;
                var stride = 0;
                var offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.oldV);
                gl.vertexAttribPointer(programInfo.attribLocations.oldV,
                    size, type, normalize, stride, offset);
                gl.enableVertexAttribArray(programInfo.attribLocations.oldV);

                var size = 1;
                var type = gl.INT;
                var normalize = false;
                var stride = 0;
                var offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.currentIndex);
                gl.vertexAttribIPointer(programInfo.attribLocations.currentIndex,
                    size, type, normalize, stride, offset);
                gl.enableVertexAttribArray(programInfo.attribLocations.currentIndex);

                gl.useProgram(programInfo.program);

                nextFrame(gl, programInfo, buffers, options);
            }

            function nextFrame(gl, programInfo, buffers, options) {
                var emptyDataArray = new Float32Array(options.particleLimit * 2);
                var emptyDataArray2 = new Float32Array(options.particleLimit * 2);

                const tf = gl.createTransformFeedback();
                gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);

                gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, buffers.newPos);
                gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER, emptyDataArray, gl.STATIC_READ);
                gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, null);
                gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, buffers.newPos);

                gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, buffers.newV);
                gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER, emptyDataArray2, gl.STATIC_READ);
                gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, null);
                gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, buffers.newV);

                gl.beginTransformFeedback(gl.POINTS);

                var offset = 0;
                var vertexCount = options.particleLimit;
                gl.drawArrays(gl.POINTS, offset, vertexCount);

                var count = 0;
                gl.endTransformFeedback();
                gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

                const fence = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
                gl.flush();
                setTimeout(waitForResult);
                function waitForResult() {
                    const status = gl.clientWaitSync(fence, 0, 0);
                    if (status === gl.CONDITION_SATISFIED || status === gl.ALREADY_SIGNALED) {
                        gl.deleteSync(fence);
                        const output = new Float32Array(vertexCount * 2);

                        // copy the previous "newPos" values to the current "oldPos"
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.newPos);
                        gl.getBufferSubData(gl.ARRAY_BUFFER, 0, output);
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.oldPos);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(output), gl.DYNAMIC_DRAW);

                        var size = 2;
                        var type = gl.FLOAT;
                        var normalize = false;
                        var stride = 0;
                        var offset = 0;
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.oldPos);

                        gl.vertexAttribPointer(programInfo.attribLocations.oldPos,
                            size, type, normalize, stride, offset);
                        gl.enableVertexAttribArray(programInfo.attribLocations.oldPos);

                        gl.uniform2fv(programInfo.uniformLocations.allPositions, output);

                        // copy the previous "newV" values to the current "oldV"
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.newV);
                        gl.getBufferSubData(gl.ARRAY_BUFFER, 0, output);
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.oldV);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(output), gl.DYNAMIC_DRAW);

                        gl.vertexAttribPointer(programInfo.attribLocations.oldV,
                            size, type, normalize, stride, offset);
                        gl.enableVertexAttribArray(programInfo.attribLocations.oldV);

                        nextFrame(gl, programInfo, buffers, options);
                    } else {
                        setTimeout(waitForResult);
                    }
                }
            }
        </script>
    </body>
</html>
