<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Morphogen</title>
        <style type="text/css">
            body {
                background: radial-gradient(circle at top, #336, #000 75%);
                min-height: 100vh;
                padding: 0 1em;
                margin: 0;
                text-align: center;
            }
            #canvas {
                margin: 10pt;
                height: 600px;
                width: 800px;
                background: #000;
                box-shadow: 0 0 10px #429;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <script type="x-shader/x-vertex" id="vertex-shader">
            #version 300 es
            const int particleLimit = 50;
            uniform vec2 allPositions[particleLimit];
            in vec4 aVertexPosition;
            in vec4 aVertexVelocity;
            in int myIndex;
            out vec2 newPos;
            out vec2 newV;
            out lowp vec4 color;

            void main() {
                gl_Position = aVertexPosition;

                vec2 particle_pos;
                vec2 center_of_mass;
                center_of_mass = vec2(0.0, 0.0);
                for (int i = 0; i < particleLimit; i++) {
                    particle_pos = allPositions[i];
                    center_of_mass += particle_pos;
                }
                center_of_mass /= float(particleLimit) * 1.1;
                vec2 dist = allPositions[myIndex] - center_of_mass;

                newPos.x = aVertexPosition.x + aVertexVelocity.x;
                newPos.y = aVertexPosition.y + aVertexVelocity.y;
                if (newPos.x < -1.0) {
                    newPos.x = -1.0;
                }
                if (newPos.x > 1.0) {
                    newPos.x = 1.0;
                }
                if (newPos.y < -1.0) {
                    newPos.y = -1.0;
                }
                if (newPos.y > 1.0) {
                    newPos.y = 1.0;
                }
                newV.x = aVertexVelocity.x - dist.x / 10000.0;
                newV.y = aVertexVelocity.y - dist.y / 10000.0;
                color.b = min(1.0, max(0.0, abs(newV.x) * 255.0));
                color.g = min(1.0, max(0.0, abs(newV.y) * 255.0));
                color.r = 1.0 - (color.r + color.b) / 2.0;
                color.a = 1.0;
            }
        </script>
        <script type="x-shader/x-fragment" id="fragment-shader">
            #version 300 es
            precision highp float;
            in vec4 color;
            out vec4 outColor;
            void main() { outColor = color; }
        </script>
        <script type="application/javascript">
            "use strict";

            main();

            function main() {
                const canvas = document.querySelector('#canvas');
                const gl = canvas.getContext('webgl2');
                if (!gl) {
                    alert('Unable to initialize WebGL. Your browser or machine may not support it.');
                    return;
                }
                var options = {
                    particleLimit: 50,
                };
                const shaderInfo = initializeShaders(gl);
                const buffers = initBuffers(gl, options);
                drawScene(gl, shaderInfo, buffers, options);
            }

            function initializeShaders(gl) {
                const vertexShaderSource = document.getElementById("vertex-shader").text
                const fragmentShaderSource = document.getElementById("fragment-shader").text
                const shaderProgram = createProgram(gl, vertexShaderSource, fragmentShaderSource);

                const shaderInfo = {
                    program: shaderProgram,
                    attribLocations: {
                        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                        vertexVelocity: gl.getAttribLocation(shaderProgram, 'aVertexVelocity'),
                        myIndex: gl.getAttribLocation(shaderProgram, 'myIndex'),
                    },
                    uniformLocations: {
                        allPositions: gl.getUniformLocation(shaderProgram, 'allPositions'),
                    },
                };
                return shaderInfo;
            }

            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
                const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource.trim());
                const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource.trim());
                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.transformFeedbackVaryings(shaderProgram, ['newPos', 'newV'], gl.SEPARATE_ATTRIBS);
                gl.linkProgram(shaderProgram);

                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                    return null;
                }
                return shaderProgram;
            }

            function initBuffers(gl, options) {
                const positions = [...Array(options.particleLimit * 2)].map(_=>Math.random() * 2 - 1);
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);

                const velocities = [...Array(options.particleLimit * 2)].map(_=>(Math.random() * 2 - 1) * 0.005);
                const velocityBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, velocityBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(velocities), gl.DYNAMIC_DRAW);

                var indices = [];
                var i;
                for (i = 0; i < options.particleLimit; i++) {
                    indices[i] = i;
                }
                const myIndexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, myIndexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Int32Array(indices), gl.STATIC_DRAW);

                var newPosBuffer = gl.createBuffer();
                var newVBuffer = gl.createBuffer();

                return {
                    position: positionBuffer,
                    velocities: velocityBuffer,
                    newPos: newPosBuffer,
                    newV: newVBuffer,
                    indices: myIndexBuffer,
                };
            }

            function drawScene(gl, programInfo, buffers, options) {
                gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
                gl.clearDepth(1.0);                 // Clear everything
                gl.enable(gl.DEPTH_TEST);           // Enable depth testing
                gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                const vao = gl.createVertexArray();
                gl.bindVertexArray(vao);

                var size = 2;
                var type = gl.FLOAT;
                var normalize = false;
                var stride = 0;
                var offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition,
                    size, type, normalize, stride, offset);
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

                // TODO: pass all positions on first frame too.

                var size = 2;
                var type = gl.FLOAT;
                var normalize = false;
                var stride = 0;
                var offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.velocities);
                gl.vertexAttribPointer(programInfo.attribLocations.vertexVelocity,
                    size, type, normalize, stride, offset);
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexVelocity);

                var size = 1;
                var type = gl.INT;
                var normalize = false;
                var stride = 0;
                var offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.indices);
                gl.vertexAttribIPointer(programInfo.attribLocations.myIndex,
                    size, type, normalize, stride, offset);
                gl.enableVertexAttribArray(programInfo.attribLocations.myIndex);

                gl.useProgram(programInfo.program);

                nextFrame(gl, programInfo, buffers, options);
            }

            function nextFrame(gl, programInfo, buffers, options) {
                var emptyDataArray = new Float32Array(options.particleLimit * 2);
                var emptyDataArray2 = new Float32Array(options.particleLimit * 2);

                const tf = gl.createTransformFeedback();
                gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);

                gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, buffers.newPos);
                gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER, emptyDataArray, gl.STATIC_READ);
                gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, null);
                gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, buffers.newPos);

                gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, buffers.newV);
                gl.bufferData(gl.TRANSFORM_FEEDBACK_BUFFER, emptyDataArray2, gl.STATIC_READ);
                gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, null);
                gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, buffers.newV);

                gl.beginTransformFeedback(gl.POINTS);

                var offset = 0;
                var vertexCount = options.particleLimit;
                gl.drawArrays(gl.POINTS, offset, vertexCount);

                var count = 0;
                gl.endTransformFeedback();
                gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

                const fence = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
                gl.flush();
                setTimeout(waitForResult);
                function waitForResult() {
                    const status = gl.clientWaitSync(fence, 0, 0);
                    if (status === gl.CONDITION_SATISFIED || status === gl.ALREADY_SIGNALED) {
                        gl.deleteSync(fence);
                        const output = new Float32Array(vertexCount * 2);

                        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.newPos);
                        gl.getBufferSubData(gl.ARRAY_BUFFER, 0, output);
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(output), gl.DYNAMIC_DRAW);

                        var size = 2;
                        var type = gl.FLOAT;
                        var normalize = false;
                        var stride = 0;
                        var offset = 0;
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);

                        gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition,
                            size, type, normalize, stride, offset);
                        gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

                        gl.uniform2fv(programInfo.uniformLocations.allPositions, output);

                        //----
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.newV);
                        gl.getBufferSubData(gl.ARRAY_BUFFER, 0, output);
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.velocities);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(output), gl.DYNAMIC_DRAW);

                        gl.vertexAttribPointer(programInfo.attribLocations.vertexVelocity,
                            size, type, normalize, stride, offset);
                        gl.enableVertexAttribArray(programInfo.attribLocations.vertexVelocity);

                        nextFrame(gl, programInfo, buffers, options);
                    } else {
                        setTimeout(waitForResult);
                    }
                }
            }
        </script>
    </body>
</html>
